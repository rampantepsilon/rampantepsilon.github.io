var c=Object.defineProperty;var i=(G,Q)=>{for(var X in Q)c(G,X,{get:Q[X],enumerable:!0,configurable:!0,set:(Y)=>Q[X]=()=>Y})};var o={};i(o,{slotTypes:()=>_,permissions:()=>n,itemsHandlingFlags:()=>N,itemClassifications:()=>R,clientStatuses:()=>W});var W={disconnected:0,connected:5,ready:10,playing:20,goal:30},R={progression:1,useful:2,trap:4,normal:0},N={minimal:0,others:1,own:2,starting:4,all:7},n={disabled:0,enabled:1,goal:2,auto:6,autoEnabled:7},_={spectator:0,player:1,group:2};class x extends Error{}class D extends Error{argumentName;value;constructor(G,Q,X){super(G);this.argumentName=Q,this.value=structuredClone(X)}}class T extends Error{errors=[];constructor(G,Q){super(G);this.errors=Q}}class K extends Error{}var C={timeout:1e4,autoFetchDataPackage:!0,maximumMessages:1000,debugLogVersions:!0};var r={major:0,minor:5,build:1},l="2.0.2";function F(){const G=[];for(let Q=0;Q<36;Q++)G.push(Math.floor(Math.random()*16));return G[14]=4,G[19]=G[19]&=-5,G[19]=G[19]|=8,G[8]=G[13]=G[18]=G[23]="-",G.map((Q)=>Q.toString(16)).join("")}var H={password:"",uuid:F(),tags:[],version:r,items:N.all,slotData:!0};class z{#G;#Q;#X;#Y;constructor(G,Q,X,Y){this.#G=G,this.#Q=Q,this.#X=X,this.#Y=Y}toString(){return this.name}get receiver(){return this.#Y}get sender(){return this.#X}get name(){return this.#G.package.lookupItemName(this.game,this.#Q.item,!0)}get id(){return this.#Q.item}get locationName(){return this.#G.package.lookupLocationName(this.sender.game,this.#Q.location,!0)}get locationId(){return this.#Q.location}get locationGame(){return this.sender.game}get game(){return this.receiver.game}get progression(){return(this.flags&R.progression)===R.progression}get useful(){return(this.flags&R.useful)===R.useful}get trap(){return(this.flags&R.trap)===R.trap}get filler(){return this.flags===R.normal}get flags(){return this.#Q.flags}}class O{game;checksum;itemTable;locationTable;reverseItemTable;reverseLocationTable;constructor(G,Q){this.game=G,this.checksum=Q.checksum,this.itemTable=Object.freeze(Q.item_name_to_id),this.locationTable=Object.freeze(Q.location_name_to_id),this.reverseItemTable=Object.freeze(Object.fromEntries(Object.entries(this.itemTable).map(([X,Y])=>[Y,X]))),this.reverseLocationTable=Object.freeze(Object.fromEntries(Object.entries(this.locationTable).map(([X,Y])=>[Y,X])))}exportPackage(){return{checksum:this.checksum,item_name_to_id:{...this.itemTable},location_name_to_id:{...this.locationTable}}}}class I{#G;#Q=new Map;#X=new Map;#Y=new Set;constructor(G){this.#G=G,this.#G.socket.on("roomInfo",(Q)=>{this.#Q.clear(),this.#X.clear(),this.#Y.clear(),this.#Q.set("Archipelago",this.#Z());for(let X in Q.datapackage_checksums)this.#X.set(X,Q.datapackage_checksums[X]),this.#Y.add(X)})}findPackage(G){return this.#Q.get(G)??null}async fetchPackage(G=[],Q=!0){if(G.length===0)G=Array.from(this.#Y);G=G.filter((Y)=>{if(!this.#Y.has(Y))return!1;if(this.#Q.get(Y)?.checksum!==this.#X.get(Y))return!0;return!1});const X={games:{}};for(let Y of G){const Z={cmd:"GetDataPackage",games:[Y]},[$]=await this.#G.socket.send(Z).wait("dataPackage");X.games[Y]=$.data.games[Y]}if(Q)this.importPackage(X);return X}importPackage(G){for(let Q in G.games)this.#Q.set(Q,new O(Q,G.games[Q])),this.#X.set(Q,G.games[Q].checksum)}exportPackage(){return{games:this.#Q.entries().reduce((G,[Q,X])=>{return G[Q]=X.exportPackage(),G},{})}}lookupItemName(G,Q,X=!0){const Y=`Unknown Item ${Q}`,Z=this.findPackage(G);if(!Z)return X?Y:void 0;const $=Z.reverseItemTable[Q];if(X&&$===void 0)return Y;return $}lookupLocationName(G,Q,X=!0){const Y=`Unknown Location ${Q}`,Z=this.findPackage(G);if(!Z)return X?Y:void 0;const $=Z.reverseLocationTable[Q];if(X&&$===void 0)return Y;return $}#Z(){return new O("Archipelago",{checksum:"ac9141e9ad0318df2fa27da5f20c50a842afeecb",item_name_to_id:{Nothing:-1},location_name_to_id:{"Cheat Console":-1,Server:-2}})}}class S{#G;#Q=[];#X;#Y;constructor(G,Q,X){this.#G=G,this.#X=Q,this.#Y=X}replace(G){return this.#Q.push({operation:"replace",value:G}),this}default(){return this.#Q.push({operation:"default",value:null}),this}add(G){return this.#Q.push({operation:"add",value:G}),this}multiply(G){return this.#Q.push({operation:"mul",value:G}),this}power(G){return this.#Q.push({operation:"pow",value:G}),this}remainder(G){return this.#Q.push({operation:"mod",value:G}),this}floor(){return this.#Q.push({operation:"floor",value:null}),this}ceiling(){return this.#Q.push({operation:"ceil",value:null}),this}max(G){return this.#Q.push({operation:"max",value:G}),this}min(G){return this.#Q.push({operation:"min",value:G}),this}and(G){return this.#Q.push({operation:"and",value:G}),this}or(G){return this.#Q.push({operation:"or",value:G}),this}xor(G){return this.#Q.push({operation:"xor",value:G}),this}leftShift(G){return this.#Q.push({operation:"left_shift",value:G}),this}rightShift(G){return this.#Q.push({operation:"right_shift",value:G}),this}remove(G){return this.#Q.push({operation:"remove",value:G}),this}pop(G){return this.#Q.push({operation:"pop",value:G}),this}update(G){return this.#Q.push({operation:"update",value:G}),this}async commit(G=!1){const Q=F(),X={cmd:"Set",default:this.#Y,key:this.#X,operations:this.#Q,want_reply:G,uuid:Q};if(this.#G.socket.send(X),!G)return;const[Y]=await this.#G.socket.wait("setReply",(Z)=>Z.uuid===Q);return Y.value}}class A{#G;#Q={};#X={};constructor(G){this.#G=G,this.#G.socket.on("disconnected",()=>{this.#Q={},this.#X={}}).on("setReply",(Q)=>{this.#Q[Q.key]=Q.value;const X=this.#X[Q.key];if(X)X.forEach((Y)=>Y(Q.key,Q.value,Q.original_value))}).on("connected",()=>{if(this.#G.options.debugLogVersions){const Q=`${this.#G.game}:${l}:${navigator?.userAgent}`;this.prepare("archipelago.js__runtimes",{}).default().update({[Q]:!0}).commit(!1)}})}get store(){return structuredClone(this.#Q)}async fetch(G,Q=!1){let X=typeof G==="string"?[G]:G;if(Q){const Z=X.filter(($)=>this.#Q[$]===void 0);if(Z.length>0)this.#G.socket.send({cmd:"SetNotify",keys:Z})}let Y={};if(X=X.filter((Z)=>{const $=structuredClone(this.#Q[Z]),j=$!==void 0;if(j)Y[Z]=$;return!j}),X.length>0){const Z=await this.#Y(X);Y={...Y,...Z}}if(Q)this.#Q={...this.#Q,...Y};return typeof G==="string"?Y[G]:Y}async notify(G,Q){return G.forEach((X)=>{this.#X[X]??=[],this.#X[X].push(Q)}),this.fetch(G,!0)}prepare(G,Q){if(G.startsWith("_read_"))throw TypeError("Cannot manipulate read only keys.");return new S(this.#G,G,Q)}async fetchItemNameGroups(G){return await this.fetch([`_read_item_name_groups_${G}`],!0)}async fetchLocationNameGroups(G){return await this.fetch([`_read_location_name_groups_${G}`],!0)}async#Y(G){const Q=F(),[X]=await this.#G.socket.send({cmd:"Get",keys:G,uuid:Q}).wait("retrieved",(Y)=>Y.uuid===Q);return X.keys}}class E{#G={};addEventListener(G,Q,X=!1){this.#G[G]??=[],this.#G[G].push([Q,X])}removeEventListener(G,Q){const X=this.#G[G];if(X&&X.length>0)this.#G[G]=X.filter(([Y])=>Y!==Q)}dispatchEvent(G,Q){const X=this.#G[G]??[];for(let[Y,Z]of X)if(Y(...Q),Z)this.removeEventListener(G,Y)}}class J{#G=new E;on(G,Q){return this.#G.addEventListener(G,Q),this}off(G,Q){return this.#G.removeEventListener(G,Q),this}async wait(G,Q=()=>!0){return new Promise((X)=>{const Y=(...Z)=>{if(Q(...Z))this.#G.removeEventListener(G,Y),X(Z)};this.#G.addEventListener(G,Y)})}emit(G,Q){this.#G.dispatchEvent(G,Q)}}class M extends J{#G;#Q=Number.MIN_SAFE_INTEGER;constructor(G){super();this.#G=G,this.#G.socket.on("bounced",(Q)=>{if(Q.tags?.includes("DeathLink")&&Q.data.time&&Q.data.source){const X=Q.data;if(X.time===this.#Q)return;this.#Q=X.time,this.emit("deathReceived",[X.source,X.time*1000,X.cause])}})}get enabled(){return this.#G.arguments.tags.includes("DeathLink")}enableDeathLink(){if(this.#G.arguments.tags.includes("DeathLink"))return;this.#G.updateTags([...this.#G.arguments.tags,"DeathLink"])}disableDeathLink(){if(!this.#G.arguments.tags.includes("DeathLink"))return;this.#G.updateTags(this.#G.arguments.tags.filter((G)=>G!=="DeathLink"))}sendDeathLink(G,Q){if(!this.#G.authenticated)throw new K("Cannot send death links before connecting and authenticating.");if(!this.enabled)return;this.#Q=Math.ceil(Date.now()/1000);const X={source:G,cause:Q,time:this.#Q};this.#G.bounce({tags:["DeathLink"]},X)}}class V{#G;#Q;#X;constructor(G,Q){this.#G=G,this.#Q=Q,this.#X=new z(this.#G,{item:Q.item,location:Q.location,player:Q.finding_player,flags:Q.item_flags},this.#G.players.findPlayer(Q.finding_player),this.#G.players.findPlayer(Q.receiving_player))}get item(){return this.#X}get found(){return this.#Q.found}get entrance(){return this.#Q.entrance||"Vanilla"}}class f extends J{#G;#Q=[];#X=[];constructor(G){super();this.#G=G,this.#G.socket.on("receivedItems",(Q)=>{let X=Q.index;const Y=Q.items.length,Z=[...Q.items];while(Z.length>0){const $=Z.shift();this.#Q[X++]=new z(this.#G,$,this.#G.players.findPlayer($.player),this.#G.players.self)}this.emit("itemsReceived",[this.#Q.slice(Q.index,Q.index+Y),Q.index])}).on("connected",()=>{this.#X=[],this.#Q=[],this.#G.storage.notify([`_read_hints_${this.#G.players.self.team}_${this.#G.players.self.slot}`],this.#Y.bind(this)).then((Q)=>{const X=Q[`_read_hints_${this.#G.players.self.team}_${this.#G.players.self.slot}`];this.#X=X.map((Y)=>new V(this.#G,Y)),this.emit("hintsInitialized",[this.#X])}).catch((Q)=>{throw Q})})}get received(){return[...this.#Q]}get hints(){return[...this.#X]}get count(){return this.#Q.length}#Y(G,Q){for(let X=0;X<Q.length;X++)if(this.#X[X]===void 0)this.#X[X]=new V(this.#G,Q[X]),this.emit("hintReceived",[this.#X[X]]);else if(this.#X[X].found!==Q[X].found)this.#X[X]=new V(this.#G,Q[X]),this.emit("hintFound",[this.#X[X]])}}class P{client;part;constructor(G,Q){this.client=G,this.part=Q}toString(){return this.text}}class w extends P{part;type="item";item;constructor(G,Q,X,Y){super(G,Q);const Z=G.players.findPlayer(Q.player,Y.team);this.part=Q,this.item=new z(G,X,Z,Y)}get text(){return this.item.name}}class b extends P{#G;part;type="location";id;constructor(G,Q){super(G,Q);const X=G.players.findPlayer(Q.player),Y=G.package.findPackage(X.game);if(this.part=Q,Q.type==="location_name")this.#G=Q.text,this.id=Y.locationTable[Q.text];else this.id=parseInt(Q.text),this.#G=G.package.lookupLocationName(X.game,this.id,!0)}get text(){return this.#G}}class v extends P{part;type="color";color;constructor(G,Q){super(G,Q);this.part=Q,this.color=Q.color}get text(){return this.part.text}}class y extends P{part;type;constructor(G,Q){super(G,Q);if(this.part=Q,this.part.type==="entrance_name")this.type="entrance";else this.type="text"}get text(){return this.part.text}}class m extends P{part;type="player";player;constructor(G,Q){super(G,Q);if(this.part=Q,Q.type==="player_id")this.player=G.players.findPlayer(parseInt(Q.text));else{const X=G.players.teams[G.players.self.team].find((Y)=>Y.name===Q.text);if(!X)throw new Error(`Cannot find player under name: ${Q.text}`);this.player=X}}get text(){return this.player.alias}}class u extends J{#G;#Q=[];get log(){return[...this.#Q]}constructor(G){super();this.#G=G,this.#G.socket.on("printJSON",this.#X.bind(this))}async say(G){if(!this.#G.authenticated)throw new K("Cannot send chat messages without being authenticated.");G=G.trim();const Q={cmd:"Say",text:G};this.#G.socket.send(Q),await this.wait("chat",(X)=>X===G)}#X(G){const Q=[];for(let Y of G.data)switch(Y.type){case"item_id":case"item_name":{const Z=G;let $;if(Z.type==="ItemCheat")$=this.#G.players.findPlayer(Z.receiving,Z.team);else $=this.#G.players.findPlayer(Z.receiving);Q.push(new w(this.#G,Y,Z.item,$));break}case"location_id":case"location_name":{Q.push(new b(this.#G,Y));break}case"color":{Q.push(new v(this.#G,Y));break}case"player_id":case"player_name":{Q.push(new m(this.#G,Y));break}default:{Q.push(new y(this.#G,Y));break}}const X=Q.map((Y)=>Y.text).join();if(this.#G.options.maximumMessages>=1)this.log.push({text:X,nodes:Q}),this.log.splice(0,this.log.length-this.#G.options.maximumMessages);switch(G.type){case"ItemSend":{const Y=this.#G.players.findPlayer(G.item.player),Z=this.#G.players.findPlayer(G.receiving),$=new z(this.#G,G.item,Y,Z);this.emit("itemSent",[X,$,Q]);break}case"ItemCheat":{const Y=this.#G.players.findPlayer(G.item.player,G.team),Z=this.#G.players.findPlayer(G.receiving,G.team),$=new z(this.#G,G.item,Y,Z);this.emit("itemCheated",[X,$,Q]);break}case"Hint":{const Y=this.#G.players.findPlayer(G.item.player),Z=this.#G.players.findPlayer(G.receiving),$=new z(this.#G,G.item,Y,Z);this.emit("itemHinted",[X,$,G.found,Q]);break}case"Join":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("connected",[X,Y,G.tags,Q]);break}case"Part":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("disconnected",[X,Y,Q]);break}case"Chat":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("chat",[G.message,Y,Q]);break}case"ServerChat":{this.emit("serverChat",[G.message,Q]);break}case"TagsChanged":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("tagsUpdated",[X,Y,G.tags,Q]);break}case"Tutorial":{this.emit("tutorial",[X,Q]);break}case"CommandResult":{this.emit("userCommand",[X,Q]);break}case"AdminCommandResult":{this.emit("adminCommand",[X,Q]);break}case"Goal":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("goaled",[X,Y,Q]);break}case"Release":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("released",[X,Y,Q]);break}case"Collect":{const Y=this.#G.players.findPlayer(G.slot,G.team);this.emit("collected",[X,Y,Q]);break}case"Countdown":this.emit("countdown",[X,G.countdown,Q])}this.emit("message",[X,Q])}}class q{#G;#Q;constructor(G,Q){this.#G=G,this.#Q=Q}toString(){return this.alias}get name(){return this.#Q.name}get alias(){return this.#Q.alias}get game(){if(this.slot===0)return"Archipelago";return this.#X.game}get type(){if(this.slot===0)return _.spectator;return this.#X.type}get team(){return this.#Q.team}get slot(){return this.#Q.slot}get members(){if(this.type!==_.group)return[];return this.#G.players.teams[this.team].filter((G)=>this.#X.group_members.includes(G.slot))}get groups(){if(this.slot===0)return[];return this.#G.players.teams[this.team].filter((G)=>G.slot!==0&&this.#G.players.slots[G.slot].group_members.includes(this.slot))}async fetchStatus(){if(this.type===_.group)return W.goal;return await this.#G.storage.fetch(`_read_client_status_${this.team}_${this.slot}`)??0}async fetchSlotData(){return await this.#G.storage.fetch(`_read_slot_data_${this.slot}`)}async fetchHints(){return(await this.#G.storage.fetch(`_read_hints_${this.team}_${this.slot}`)).map((Q)=>new V(this.#G,Q))}get#X(){return this.#G.players.slots[this.slot]}}class g extends J{#G;#Q=[];#X={};#Y=0;#Z=0;constructor(G){super();this.#G=G,this.#G.socket.on("connected",(Q)=>{this.#X=Object.freeze(Q.slot_info),this.#Q=[],this.#Y=Q.slot,this.#Z=Q.team;for(let X of Q.players)this.#Q[X.team]??=[{team:X.team,slot:0,name:"Archipelago",alias:"Archipelago"}],this.#Q[X.team][X.slot]=X}).on("roomUpdate",(Q)=>{if(!Q.players)return;for(let X of Q.players)if(this.#Q[X.team][X.slot].alias!==X.alias){const Y=this.#Q[X.team][X.slot].alias;this.#Q[X.team][X.slot]=X,this.emit("aliasUpdated",[new q(this.#G,X),Y,X.alias])}})}get self(){if(this.#Y===0)throw new Error("Cannot lookup own player object when client has never connected to a server.");return new q(this.#G,this.#Q[this.#Z][this.#Y])}get slots(){return this.#X}get teams(){const G=[];for(let Q=0;Q<this.#Q.length;Q++){G[Q]=[];for(let X=0;X<this.#Q[Q].length;X++)G[Q].push(new q(this.#G,this.#Q[Q][X]))}return G}findPlayer(G,Q){if(Q===void 0)Q=this.#G.players.self.team;if(this.#Q[Q])return new q(this.#G,this.#Q[Q][G]);return}}class h extends J{#G;#Q={major:-1,minor:-1,build:-1};#X={major:-1,minor:-1,build:-1};#Y=[];#Z=[];#V="";#x=!1;#z=0;#U=0;#J=0;#K={release:0,collect:0,remaining:0};#R=[];#$=[];#F=!1;get serverVersion(){return{...this.#Q}}get generatorVersion(){return{...this.#X}}get games(){return[...this.#Y]}get tags(){return[...this.#Z]}get seedName(){return this.#V}get password(){return this.#x}get permissions(){return{...this.#K}}get hintPoints(){return this.#z}get hintCost(){if(this.hintCostPercentage>0)return Math.max(1,Math.floor(this.hintCostPercentage*this.allLocations.length*0.01));return 0}get hintCostPercentage(){return this.#U}get locationCheckPoints(){return this.#J}get missingLocations(){return[...this.#R].sort()}get checkedLocations(){return[...this.#$].sort()}get allLocations(){return[...this.#R,...this.#$].sort()}get race(){return this.#F}constructor(G){super();this.#G=G,this.#G.socket.on("roomInfo",(Q)=>{this.#Q={major:Q.version.major,minor:Q.version.minor,build:Q.version.build},this.#X={major:Q.generator_version.major,minor:Q.generator_version.minor,build:Q.generator_version.build},this.#Z=Q.tags,this.#Y=Q.games,this.#V=Q.seed_name,this.#x=Q.password,this.#K=Q.permissions,this.#U=Q.hint_cost,this.#J=Q.location_check_points}).on("connected",(Q)=>{this.#R=Q.missing_locations,this.#$=Q.checked_locations,this.emit("locationsChecked",[this.checkedLocations]),this.#z=Q.hint_points,this.emit("hintPointsUpdated",[0,Q.hint_points])}).on("roomUpdate",(Q)=>{if(Q.hint_cost!==void 0){const[X,Y]=[this.hintCost,this.hintCostPercentage];this.#U=Q.hint_cost,this.emit("hintCostUpdated",[X,this.hintCost,Y,this.hintCostPercentage])}if(Q.hint_points!==void 0){const X=this.#z;this.#z=Q.hint_points,this.emit("hintPointsUpdated",[X,this.hintPoints])}if(Q.location_check_points!==void 0){const X=this.#J;this.#J=Q.location_check_points,this.emit("locationCheckPointsUpdated",[X,this.locationCheckPoints])}if(Q.password!==void 0)this.#x=Q.password,this.emit("passwordUpdated",[this.password]);if(Q.permissions!==void 0){const X=this.#K;this.#K=Q.permissions,this.emit("permissionsUpdated",[X,this.permissions])}if(Q.checked_locations!==void 0)this.#$=[...this.#$,...Q.checked_locations],this.#R=this.missingLocations.filter((X)=>!Q.checked_locations?.includes(X)),this.emit("locationsChecked",[Q.checked_locations])})}}class d extends J{#G=null;#Q=!1;constructor(){super()}get connected(){return this.#Q}get url(){return this.#G?.url??""}send(...G){if(this.#G)return this.#G.send(JSON.stringify(G)),this.emit("sentPackets",[G]),this;throw new x("Unable to send packets to the server; not connected to a server.")}async connect(G){if(this.disconnect(),typeof G==="string"){if(!/^([a-zA-Z]+:)\/\/[A-Za-z0-9_.~\-:]+/i.test(G))try{return await this.connect(new URL(`wss://${G}`))}catch{return await this.connect(new URL(`ws://${G}`))}G=new URL(G)}if(G.port=G.port||"38281",G.protocol!=="wss:"&&G.protocol!=="ws:")throw new TypeError("Unexpected protocol. Archipelago only supports the ws:// and wss:// protocols.");try{return new Promise((Q,X)=>{const Y=this.#Y();if(Y===null)throw new x("Unable to find a suitable WebSocket API in the current runtime.");this.#G=new Y(G),this.#G.onmessage=this.#X.bind(this),this.#G.onclose=()=>{this.disconnect(),X(new x("Failed to connect to Archipelago server."))},this.#G.onerror=()=>{this.disconnect(),X(new x("Failed to connect to Archipelago server."))},this.#G.onopen=()=>{this.wait("roomInfo").then(([Z])=>{if(this.#Q=!0,this.#G){this.#G.onclose=this.disconnect.bind(this),this.#G.onerror=this.disconnect.bind(this),Q(Z);return}this.disconnect(),X(new x("Failed to connect to Archipelago server."))}).catch((Z)=>{throw Z})}})}catch(Q){throw this.disconnect(),Q}}disconnect(){if(!this.connected)return;this.#Q=!1,this.#G?.close(),this.#G=null,this.emit("disconnected",[])}#X(G){const Q=JSON.parse(G.data);for(let X of Q){switch(X.cmd){case"ConnectionRefused":this.emit("connectionRefused",[X]);break;case"Bounced":this.emit("bounced",[X,X.data]);break;case"Connected":this.emit("connected",[X]);break;case"DataPackage":this.emit("dataPackage",[X]);break;case"InvalidPacket":this.emit("invalidPacket",[X]);break;case"LocationInfo":this.emit("locationInfo",[X]);break;case"PrintJSON":this.emit("printJSON",[X]);break;case"ReceivedItems":this.emit("receivedItems",[X]);break;case"Retrieved":this.emit("retrieved",[X]);break;case"RoomInfo":this.emit("roomInfo",[X]);break;case"RoomUpdate":this.emit("roomUpdate",[X]);break;case"SetReply":this.emit("setReply",[X]);break}this.emit("receivedPacket",[X])}}#Y(){let G=null;if(typeof window!=="undefined")G=window.WebSocket||window.MozWebSocket;else if(typeof global!=="undefined")G=global.WebSocket||global.MozWebSocket;else if(typeof self!=="undefined")G=self.WebSocket||self.MozWebSocket;else if(typeof WebSocket!=="undefined")G=WebSocket;else if(typeof MozWebSocket!=="undefined")G=MozWebSocket;return G}}class s{#G=!1;#Q=H;#X="";#Y="";socket=new d;package=new I(this);storage=new A(this);room=new h(this);players=new g(this);items=new f(this);messages=new u(this);deathLink=new M(this);options;get authenticated(){return this.socket.connected&&this.#G}get name(){return this.#X}get game(){return this.#Y}get arguments(){return{...this.#Q}}constructor(G){if(G)this.options={...C,...G};else this.options={...C};this.socket.on("disconnected",()=>{this.#G=!1}).on("sentPackets",(Q)=>{for(let X of Q)if(X.cmd==="ConnectUpdate")this.#Q.tags=X.tags,this.#Q.items=X.items_handling})}async login(G,Q,X="",Y){if(Q==="")throw new D("Provided slot name cannot be blank.","name",Q);if(Y)this.#Q={...H,...Y};else this.#Q={...H};const Z=new Set(this.arguments.tags);if(!X&&!Z.has("HintGame")&&!Z.has("Tracker")&&!Z.has("TextOnly"))Z.add("TextOnly");this.#Q.tags=Array.from(Z);const $={cmd:"Connect",name:Q,game:X,password:this.arguments.password,slot_data:this.arguments.slotData,items_handling:this.arguments.items,uuid:this.arguments.uuid,tags:this.arguments.tags,version:{...this.arguments.version,class:"Version"}};if(await this.socket.connect(G),this.options.autoFetchDataPackage)await this.package.fetchPackage();return new Promise((j,k)=>{const p=setTimeout(()=>k(new x("Server failed to respond in time.")),this.options.timeout),B=(U)=>{this.#G=!0,this.#Y=U.slot_info[U.slot].game,this.#X=U.slot_info[U.slot].name,this.socket.off("connected",B).off("connectionRefused",L),clearTimeout(p),j(U.slot_data)},L=(U)=>{this.socket.off("connected",B).off("connectionRefused",L),clearTimeout(p),k(new T(`Connection was refused by the server. Reason(s): [${U.errors?.join(", ")}`,U.errors??[]))};this.socket.on("connected",B.bind(this)).on("connectionRefused",L.bind(this)).send($)})}updateStatus(G){if(!this.authenticated)throw new K("Cannot update status while not connected and authenticated.");this.socket.send({cmd:"StatusUpdate",status:G})}goal(){this.updateStatus(W.goal)}updateTags(G){if(!this.authenticated)throw new K("Cannot update tags while not connected and authenticated.");this.socket.send({cmd:"ConnectUpdate",tags:G,items_handling:this.arguments.items})}updateItemsHandling(G){if(!this.authenticated)throw new K("Cannot update tags while not connected and authenticated.");this.socket.send({cmd:"ConnectUpdate",tags:this.arguments.tags,items_handling:G})}check(...G){if(!this.authenticated)throw new K("Cannot check locations while not connected and authenticated.");G=G.filter((Q)=>this.room.missingLocations.includes(Q)),this.socket.send({cmd:"LocationChecks",locations:G})}async scout(G,Q=0){if(!this.authenticated)throw new K("Cannot scout locations while not connected and authenticated.");G=G.filter((Y)=>this.room.allLocations.includes(Y));const[X]=await this.socket.send({cmd:"LocationScouts",create_as_hint:Q,locations:G}).wait("locationInfo",(Y)=>{return Y.locations.map((Z)=>Z.location).toSorted().join(",")===G.toSorted().join(",")});return X.locations.map((Y)=>new z(this,Y,this.players.self,this.players.findPlayer(Y.player)))}bounce(G,Q){if(!this.authenticated)throw new K("Cannot send bounces while not connected and authenticated.");this.socket.send({cmd:"Bounce",data:Q,games:G.games??[],slots:G.slots??[],tags:G.tags??[]})}}export{r as targetVersion,l as libraryVersion,H as defaultConnectionOptions,C as defaultClientOptions,y as TextualMessageNode,d as SocketManager,h as RoomStateManager,g as PlayersManager,m as PlayerMessageNode,q as Player,O as PackageMetadata,u as MessageManager,b as LocationMessageNode,f as ItemsManager,w as ItemMessageNode,z as Item,S as IntermediateDataOperation,V as Hint,J as EventBasedManager,M as DeathLinkManager,A as DataStorageManager,I as DataPackageManager,v as ColorMessageNode,s as Client,P as BaseMessageNode,o as API};
